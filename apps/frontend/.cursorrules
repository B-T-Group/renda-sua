# Cursor Rules for Frontend App - Reusable Components & Best Practices

## CRITICAL COMPONENT REUSE RULES

### üîç ALWAYS SEARCH BEFORE CREATING
**MANDATORY**: Before creating ANY new component, you MUST:

1. **Search existing components first**:
   ```bash
   # Search in these directories:
   - src/components/common/     # Reusable UI components
   - src/components/business/   # Business-specific components  
   - src/components/dialogs/    # Modal/dialog components
   - src/components/layout/     # Layout components
   ```

2. **Use codebase_search to find similar patterns**:
   - Search for similar functionality: "loading", "card", "table", "form", "modal"
   - Look for existing hooks: "useLoading", "useApi", "useGraphQL"
   - Check for similar UI patterns before recreating

3. **Reuse or extend existing components**:
   - If 70%+ similar ‚Üí Extend existing component with new props
   - If 50-70% similar ‚Üí Create variant or extract common base
   - If <50% similar ‚Üí Create new component but follow established patterns

### üìè COMPONENT SIZE LIMITS
- **Maximum 20 lines per method/function** (as per project rules)
- **Maximum 200 lines per component file**
- **If larger ‚Üí Split into smaller components or extract custom hooks**

### üé® MANDATORY SKELETON LOADING

**EVERY component that loads data MUST use skeleton loading**:

```tsx
// ‚úÖ CORRECT - Always use skeleton loading
const MyComponent = () => {
  const { data, loading } = useData();
  
  if (loading) {
    return (
      <Box>
        <Skeleton variant="rectangular" height={60} sx={{ mb: 2 }} />
        <Skeleton variant="text" height={24} sx={{ mb: 1 }} />
        <Skeleton variant="text" height={20} width="80%" />
      </Box>
    );
  }
  
  return <div>{data}</div>;
};

// ‚ùå WRONG - Never use simple loading text
const BadComponent = () => {
  const { data, loading } = useData();
  
  if (loading) return <div>Loading...</div>; // ‚ùå FORBIDDEN
  
  return <div>{data}</div>;
};
```

**Required Skeleton Patterns**:
- **Cards**: `<Skeleton variant="rectangular" height={200} />`
- **Text Lines**: `<Skeleton variant="text" height={24} />`
- **Circular**: `<Skeleton variant="circular" width={40} height={40} />`
- **Tables**: Use `<Skeleton>` for each cell
- **Lists**: Array.from(new Array(5)).map() with skeleton items

### üß© REUSABLE COMPONENT HIERARCHY

#### 1. **Common Components** (`src/components/common/`)
**USE THESE FIRST** - Already available:
- `LoadingPage` - Full page loading with skeleton
- `LoadingSpinner` - Simple spinner component  
- `LoadingScreen` - Backdrop loading overlay
- `ConfirmationModal` - Yes/No confirmation dialogs
- `DashboardItemCard` - Product/item display cards
- `AccountInformation` - Account balance display
- `PhoneInput` - Phone number input with validation
- `LanguageSwitcher` - Language selection
- `Logo` - Brand logo component
- `ErrorBoundary` - Error handling wrapper

#### 2. **Dialog Components** (`src/components/dialogs/`)
**REUSE THESE** - Already available:
- `OrderDialog` - Order placement dialog
- `AddressDialog` - Address form dialog

#### 3. **Business Components** (`src/components/business/`)
**EXTEND THESE** - Domain-specific but reusable:
- `BusinessOrderCard` - Order display card
- `InventoryCards` - Inventory grid view
- `ItemsCards` - Items grid view  
- `BusinessInventoryTable` - Inventory table view

### üîÑ COMPONENT CREATION PROCESS

#### Step 1: Search & Analyze
```bash
# REQUIRED searches before creating new component:
1. codebase_search: "similar functionality description"
2. grep_search: "component name patterns"  
3. file_search: "related file names"
```

#### Step 2: Reuse Decision Matrix
- **90%+ match** ‚Üí Use existing component with new props
- **70-89% match** ‚Üí Extend existing component
- **50-69% match** ‚Üí Extract common base component
- **<50% match** ‚Üí Create new component following patterns

#### Step 3: Component Structure Template
```tsx
// ‚úÖ MANDATORY TEMPLATE for new components
import React from 'react';
import { Box, Skeleton } from '@mui/material';
import { useTranslation } from 'react-i18next';

interface ComponentNameProps {
  // Define clear, typed props
  data?: DataType;
  loading?: boolean;
  onAction?: (item: DataType) => void;
}

const ComponentName: React.FC<ComponentNameProps> = ({
  data,
  loading = false,
  onAction,
}) => {
  const { t } = useTranslation();

  // MANDATORY: Skeleton loading
  if (loading) {
    return (
      <Box>
        <Skeleton variant="rectangular" height={200} />
        <Skeleton variant="text" height={24} sx={{ mt: 1 }} />
      </Box>
    );
  }

  // MANDATORY: Empty state
  if (!data || data.length === 0) {
    return (
      <Box textAlign="center" py={4}>
        <Typography variant="body1" color="text.secondary">
          {t('common.noData')}
        </Typography>
      </Box>
    );
  }

  return (
    <Box>
      {/* Component content */}
    </Box>
  );
};

export default ComponentName;
```

### üéØ LOADING PATTERNS

#### 1. **Page-Level Loading**
```tsx
// Use LoadingPage for full page loads
if (loading) {
  return (
    <LoadingPage
      message="Loading data"
      subtitle="Please wait"
      showProgress={true}
    />
  );
}
```

#### 2. **Section-Level Loading**  
```tsx
// Use skeleton for content sections
if (loading) {
  return (
    <Box>
      {Array.from(new Array(3)).map((_, index) => (
        <Card key={index} sx={{ mb: 2 }}>
          <CardContent>
            <Skeleton variant="rectangular" height={60} />
            <Skeleton variant="text" sx={{ mt: 1 }} />
          </CardContent>
        </Card>
      ))}
    </Box>
  );
}
```

#### 3. **Table/Grid Loading**
```tsx
// Use skeleton for table rows
if (loading) {
  return (
    <TableContainer>
      <Table>
        <TableBody>
          {Array.from(new Array(5)).map((_, index) => (
            <TableRow key={index}>
              <TableCell><Skeleton /></TableCell>
              <TableCell><Skeleton /></TableCell>
              <TableCell><Skeleton /></TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
}
```

### üö´ FORBIDDEN PATTERNS

#### ‚ùå Simple Loading Text
```tsx
// NEVER DO THIS:
if (loading) return <div>Loading...</div>;
if (loading) return <CircularProgress />;
if (loading) return <Typography>Loading...</Typography>;
```

#### ‚ùå Duplicate Components
```tsx
// NEVER CREATE DUPLICATE COMPONENTS:
// Don't create LoadingSpinner2, CustomModal, etc.
// ALWAYS extend existing components instead
```

#### ‚ùå Large Components
```tsx
// NEVER CREATE COMPONENTS >200 lines
// ALWAYS split into smaller components
```

### ‚úÖ REQUIRED IMPORTS

**Every component MUST import**:
```tsx
import React from 'react';
import { Skeleton } from '@mui/material'; // For loading states
import { useTranslation } from 'react-i18next'; // For i18n
```

### üîß CUSTOM HOOKS INTEGRATION

**ALWAYS use existing hooks**:
- `useLoading` - Global loading state
- `useApiWithLoading` - API calls with loading
- `useGraphQLRequest` - GraphQL with loading
- `useUserProfile` - User profile data
- `useBusinessInventory` - Business inventory
- `useBusinessLocations` - Business locations

### üìã COMPONENT CHECKLIST

Before creating ANY component, verify:
- [ ] Searched for existing similar components
- [ ] Checked if existing component can be extended
- [ ] Includes skeleton loading for all loading states
- [ ] Uses proper TypeScript interfaces
- [ ] Includes empty state handling
- [ ] Uses translation keys (no hardcoded strings)
- [ ] Follows Material-UI design system
- [ ] Component is <200 lines
- [ ] Methods are <20 lines
- [ ] Includes proper error handling

### üèóÔ∏è ARCHITECTURE PRINCIPLES

1. **Composition over Inheritance** - Use props and composition
2. **Single Responsibility** - One component, one purpose  
3. **Reusability First** - Design for reuse from the start
4. **Loading States** - Always show skeleton loading
5. **Error Boundaries** - Wrap components in ErrorBoundary
6. **Accessibility** - Use proper ARIA labels and semantic HTML
7. **Performance** - Use React.memo for expensive components
8. **Testing** - Write tests for reusable components

---

## Translation Guidelines (Preserved from original rules)

### Common UI Elements
- "Welcome back" ‚Üí "Bon retour"
- "Loading" ‚Üí "Chargement"
- "Error" ‚Üí "Erreur"
- "Success" ‚Üí "Succ√®s"
- "Cancel" ‚Üí "Annuler"
- "Save" ‚Üí "Enregistrer"
- "Delete" ‚Üí "Supprimer"
- "Edit" ‚Üí "Modifier"
- "Add" ‚Üí "Ajouter"
- "Remove" ‚Üí "Retirer"
- "Submit" ‚Üí "Soumettre"
- "Confirm" ‚Üí "Confirmer"
- "Back" ‚Üí "Retour"
- "Next" ‚Üí "Suivant"
- "Previous" ‚Üí "Pr√©c√©dent"
- "Close" ‚Üí "Fermer"
- "Open" ‚Üí "Ouvrir"
- "Search" ‚Üí "Rechercher"
- "Filter" ‚Üí "Filtrer"
- "Sort" ‚Üí "Trier"

### Implementation Notes
- Always use translation keys from i18n files
- Keep technical terms and variable names in English
- Use proper French grammar and punctuation
- Maintain consistent terminology throughout the application 