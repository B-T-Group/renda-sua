# Cursor Rules for Rendasua Project

## Code Quality Rules

### Remove Unused Code

- Always remove any method/variable that is unused
- Check for unused imports and remove them
- Remove unused private methods and properties
- Remove unused interface properties
- Remove unused constants and enums
- Remove unused constructor parameters and their corresponding imports
- Remove unused service dependencies from NestJS modules if not used anywhere in the module

### Code Cleanup Guidelines

- Before committing code, ensure no unused methods or variables remain
- Use TypeScript strict mode to catch unused variables
- Run linters to identify unused code
- Remove dead code to improve maintainability

### Examples of What to Remove

- Unused private methods like `generateReferenceId()` if not called anywhere
- Unused imports like `randomUUID` if the method using it is removed
- Unused interface properties that are never accessed
- Unused constants or configuration values
- Unused error handling variables

## General Project Rules

### Code Quality Standards

1. **Method Length**: Keep methods under 20 lines of code
2. **Component Reusability**: Create reusable components instead of duplicating code
3. **Type Safety**: Always use proper TypeScript interfaces and types
4. **Error Handling**: Include proper try-catch blocks and error states

### Frontend Rules (React/Material-UI)

1. **Material-UI Styling**: Always use Material-UI components and styling system
2. **React Hooks**: Create domain-specific custom hooks in `src/hooks/`
3. **Modern Standards**: Follow React best practices and modern patterns
4. **Beautiful Components**: Prioritize modern, beautiful UI design
5. **Translations**: Use i18n translation keys, never hardcode strings
6. **State Management**: Use appropriate state management patterns (useState, useEffect, custom hooks)
7. **Self-Contained Components**: Prioritize self-contained components that manage their own data and dependencies

### Translation Key Organization Rules

1. **Translation Default Values**: Always provide a default value as the second parameter when using the `t()` function to ensure the UI displays meaningful text even if the translation key is missing. The default should be a human-readable, contextually appropriate string.

   ```typescript
   // Good - with default value
   t('accounts.totalBalance', 'Total Balance');
   t('orders.status.pending', 'Pending');
   t('common.loading', 'Loading...');

   // Bad - no default value
   t('accounts.totalBalance');
   t('orders.status.pending');
   ```

2. **Nested Translation Structure**: When a translation key like `orderCard.items` exists but is nested within another object (e.g., `orders.orderCard.items`), always update the translation key to use the nested structure for better organization.

3. **Context-Based Grouping**: Group related translation keys under logical parent objects:

   - Order-related keys under `orders.*`
   - Account-related keys under `accounts.*`
   - Business-related keys under `business.*`
   - Agent-related keys under `agent.*`

4. **Translation Key Discovery**: When encountering a missing translation error, always check if the key exists in a nested structure with similar context before adding it as a standalone key.

5. **Consistent Naming**: Maintain consistent naming patterns within each translation group:

   - Use camelCase for key names
   - Use descriptive, context-aware names
   - Group related functionality together

6. **Migration Strategy**: When updating translation key structures:
   - Update both English (`en.json`) and French (`fr.json`) files
   - Maintain the same nested structure in both files
   - Update any code references to use the new nested key path

### Examples of Translation Key Organization

**Before (Standalone):**

```json
{
  "orderCard": {
    "orderNumber": "Order #{{orderNumber}}",
    "items": "Items"
  }
}
```

**After (Nested):**

```json
{
  "orders": {
    "orderCard": {
      "orderNumber": "Order #{{orderNumber}}",
      "items": "Items"
    }
  }
}
```

**Usage in Code:**

```typescript
// Update from:
t('orderCard.items');

// To:
t('orders.orderCard.items');
```

### Self-Contained Component Rules

1. **Internal Data Loading**: Components should load their own data using hooks rather than receiving it as props when possible
2. **Reduced Prop Drilling**: Minimize passing data through multiple component layers
3. **Independent Functionality**: Components should be functional on their own without requiring extensive setup from parent components
4. **Error Boundary**: Each component should handle its own loading, error, and empty states
5. **Hook Usage**: Use domain-specific hooks (useBusinessLocations, useItems, etc.) directly in components that need the data
6. **Simplified Interfaces**: Keep component prop interfaces minimal and focused on configuration rather than data

### Examples of Self-Contained Components

- **Good**: `UpdateInventoryDialog` loads business locations internally using `useBusinessLocations()`
- **Bad**: `UpdateInventoryDialog` receives business locations as props from parent
- **Good**: Modal dialogs that fetch their own data when opened
- **Bad**: Components that require parents to pre-fetch and pass all necessary data

### Backend Rules (NestJS)

1. **Path Generation**: Only generate controller paths when explicitly mentioned
2. **Service Injection**: Use proper dependency injection patterns
3. **Error Handling**: Include comprehensive error handling and validation
4. **Module Organization**: Follow NestJS module structure conventions
5. **Catch Block Error Types**: Always use `error: any` type annotation in catch blocks to avoid TypeScript strict mode errors when accessing error properties

   ```typescript
   // Good - with type annotation
   } catch (error: any) {
     return {
       success: false,
       message: error.message || 'Failed to create rating',
     };
   }

   // Bad - without type annotation (causes TypeScript error)
   } catch (error) {
     return {
       success: false,
       message: error.message || 'Failed to create rating', // Error: 'error' is of type 'unknown'
     };
   }
   ```

6. **Swagger Documentation**: Always use `@nestjs/swagger` decorators when creating backend APIs for comprehensive API documentation

   ```typescript
   // Good - with Swagger decorators
   @ApiTags('ratings')
   @Controller('ratings')
   @UseGuards(AuthGuard('jwt'))
   @ApiBearerAuth()
   export class RatingsController {
     @Post()
     @HttpCode(HttpStatus.CREATED)
     @ApiOperation({ summary: 'Create a new rating' })
     @ApiResponse({
       status: 201,
       description: 'Rating created successfully',
       schema: {
         /* response schema */
       },
     })
     @ApiResponse({
       status: 400,
       description: 'Bad request - Invalid data',
       schema: {
         /* error schema */
       },
     })
     async createRating(@Body() createRatingDto: CreateRatingDto) {
       // implementation
     }
   }

   // Bad - without Swagger decorators
   @Controller('ratings')
   export class RatingsController {
     @Post()
     async createRating(@Body() createRatingDto: CreateRatingDto) {
       // implementation - no documentation
     }
   }
   ```

   **Required Swagger Decorators:**

   - `@ApiTags()` - Group related endpoints
   - `@ApiOperation()` - Describe what the endpoint does
   - `@ApiResponse()` - Document all possible response codes and schemas
   - `@ApiBearerAuth()` - For authenticated endpoints
   - `@ApiBody()` - For complex request bodies
   - `@ApiParam()` - For path parameters
     - `@ApiQuery()` - For query parameters

### GraphQL Type Safety Rules

1. **Always Create Types for GraphQL Objects**: Create TypeScript interfaces for all GraphQL query responses and objects

   ```typescript
   // Good - with proper types
   interface UserProfile {
     id: string;
     user_type_id: string;
     first_name: string;
     last_name: string;
     client?: { id: string };
     agent?: { id: string };
     business?: { id: string };
   }

   interface GraphQLResponse<T> {
     [key: string]: T[];
   }

   private async getUserProfile(userIdentifier: string): Promise<UserProfile | null> {
     const query = `...`;
     try {
       const response = await this.graphqlClient.request<GraphQLResponse<UserProfile>>(query, { userIdentifier });
       return response.users[0];
     } catch (error: any) {
       return null;
     }
   }

   // Bad - without types (causes TypeScript errors)
   private async getUserProfile(userIdentifier: string): Promise<any> {
     const query = `...`;
     try {
       const response = await this.graphqlClient.request(query, { userIdentifier });
       return response.users[0]; // Error: 'response' is of type 'unknown'
     } catch (error: any) {
       return null;
     }
   }
   ```

2. **Type Naming Convention**: Use descriptive names ending with the GraphQL object type

   - `UserProfile` for user objects
   - `OrderData` for order objects
   - `RatingData` for rating objects
   - `GraphQLResponse<T>` for generic response wrappers

3. **Required Properties**: Always define all properties that are queried
4. **Optional Properties**: Use `?` for nullable or optional GraphQL fields
5. **Nested Objects**: Create separate interfaces for nested objects when they have multiple properties

### Hasura Rules

1. **Table Tracking**: Always track tables after creation
2. **Admin Secret**: When applying migrations, use admin secret `myadminsecretkey`
3. **Migration Naming**: Follow timestamp-based migration naming convention
4. **Relationship Setup**: Define proper relationships in metadata after table creation

### File Organization

1. **Component Location**:

   - Common reusable components in `src/components/common/`
   - Business-specific components in `src/components/business/`
   - Page components in `src/components/pages/`
   - Dialog components in `src/components/dialogs/`

2. **Hook Organization**: All custom hooks in `src/hooks/` with descriptive names

3. **Type Definitions**: Define proper TypeScript interfaces for all data structures

### Refactoring Guidelines

1. **DRY Principle**: Eliminate code duplication by creating reusable components
2. **Component Extraction**: Extract large components into smaller, focused ones
3. **Props Interface**: Always define clear, typed props interfaces
4. **Confirmation Patterns**: Use ConfirmationModal for destructive actions
5. **Loading States**: Include proper loading and error states in all components

### Database and API Guidelines

1. **Schema First**: Always check database schema before writing queries
2. **Relationship Validation**: Verify relationship names and paths
3. **Permission Checks**: Understand and respect Hasura permissions
4. **Data Refresh**: Implement proper data refresh patterns after mutations

These rules ensure consistency, maintainability, and prevent common errors across the Rendasua project.
